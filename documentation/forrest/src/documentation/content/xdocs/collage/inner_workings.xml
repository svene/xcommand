<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2002-2004 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document> 
<header> 
<title>Inner Workings</title> 
</header> 
<body> 
	<p>
		This chapter describes the architecture and the design of Collage. Collage is built in a modular way.
		This makes it possible to extend and maintain it easily. To get from the Template to the desired result
		a couple of process steps are performed. Each process step is decoupled from the others as much as possible
		which results in a clear separation of concerns and makes it possible to exchange certain steps with another
		technology without affecting the other process steps. The individual steps are grouped into two categories:
	</p>
	<ul>
		<li>Template Compilation</li>
		<li>Evaluation of comiled template</li>
	</ul>

	<section id="template_compilation">
	<title>Template Compilation</title>
	<p>
		Here is the list of the process steps which get executed
		when a template is compiled:
	</p>
	<ul>
		<li>Scanning: Scan Template, recognize Symbols and convert them into Tokens (<code>templateparser.jj</code>)</li>
		<li>Parsing: each token reported by the Scanner is handed over to a <em>TokenHandlerDispatcher</em></li>
		<li>DOM Construction: The tokenhandlers will construct a DOM (document object model) representing the template</li>
	</ul>
	<p>
		The details of will be explained in a minute. But when this process has been performed a compiled template has been created
		in form of a DOM. This DOM consists of many nodes. The top one is the root node representing the template itself. It has one
		or many children which can be of type <em>TextNode</em>, <em>VariableNode</em> or <em>JavaNode</em>.
	</p>

		<section id="template_compilation_scanning">
		<title>Template Scanning</title>
		<p>
			The scanning process is supported by the tool <em>JavaCC Version 4</em> which makes it possible to define the rules
			of the scanner (see file <code>templateparser.jj</code>) to detect the symbols. At the same time the definitions include
			the grammar which builds the parsing process. Associated actions are invoked during this parsing process to hand over control to
			to the DOM Construction process.
		</p>
		<p>
			But let us start with the the scanning process. At the beginning of <code>templateparser.jj</code> the section after
			<code>PARSER_BEGIN(TemplateParser)</code> defines that the Java Class which will be generated by JavaCC from this
			file is named <code>org.collage.jcc.TemplateParser</code>. Further down it contains the definition
			<code><![CDATA[void Start(Map aCtx):]]></code> which will result in the method
			<code><![CDATA[final public void Start(Map aCtx) throws ParseException {]]></code> in the generated Parser of
			<code>TemplateParser.java</code>. Exactly this routine will be invoked from
			<code>org.collage.template.TemplateCompiler.execute(Map aCtx)</code> which thus starts the whole template compilation
			process.
		</p>
		<p>
			When <code>TemplateParser.Start()</code> is invoked the scanner is started and will look for known patterns matching the
			symbol definitions in <code>templateparser.jj</code>. When it detects one it will return it and depending on which one
			the <code>Start()</code> method will invoke the appropriate routine (<code>varStart(aCtx)</code>, <code>varName(aCtx)</code>,
			<code>varEnd(aCtx)</code>,<code>eol(aCtx)</code>, <code>javaStart(aCtx)</code>, <code>javaEnd(aCtx)</code>,
			<code>javaCode(aCtx)</code>, <code>text(aCtx)</code> or <code>eof(aCtx)</code>).
		</p>
		<p>
			If for example the characters <code>${</code> are detected this means
			that the beginning of a variable reference (e.g. <code>${name}</code>) has been detected. This is expressed through the following
			definition:
		</p>
		<p>
			<code><![CDATA[<DEFAULT> TOKEN : { < VAR_START : "${" >: IN_VAR_STATE}]]></code>
		</p>
		<p>
			which means that if the scanner is in mode <em>DEFAULT</em> and the character sequence <code>${</code> is detected the
			scanner will switch to mode <em>IN_VAR_STATE</em>. When the scanner is in this state it expects that the following characters
			are the name of the variable and then expects a closing brace which brings the scanner back in mode <em>DEFAULT</em>. This
			is expressed in the following definitions:
		</p>
<source><![CDATA[
<IN_VAR_STATE> TOKEN : { < VAR_END : "}" >: DEFAULT }
<IN_VAR_STATE> TOKEN : { <#DIGIT : ["0"-"9", "A"-"Z"] >}
<IN_VAR_STATE> TOKEN : { <#LETTER : ["a"-"z", "A"-"Z", "_"] >}
<IN_VAR_STATE> TOKEN : { < VAR_NAME : <LETTER>(<LETTER>|<DIGIT>)* > }
]]></source>

		<p>
			All the rules are expressed in a very general way. This was done to keep <code>templateparser.jj</code> as small as possible
			and to expose it as less as possible to changes. This is very important if you want to keep this file readable and thus maintainable.
			And it is important as well as no IDE will help you to find bugs in the Java code inside it. You will notice thos bugs only
			after a regeneration and recompile process which is very annoying if you have to go through this cycle many times. Since
			all of the rules work in the same way it is sufficient to look at one of them to understand how it works:
		</p>
<source><![CDATA[
void varName(Map aCtx):
{
	Token t;
}
{
	t = <VAR_NAME>
	{
		ParserCV.setToken(aCtx, t);
		ParserCV.setValue(aCtx, t.image);
		executeTokenHandler(aCtx, ParserModeCV.KEY_VAR_NAME_MODE);
	}
}
]]></source>

		<p>
			Each rule has access to the token the scanner detected. The token provides access to the so called image of the token. In the
			example abover <code>void varName(Map aCtx)</code> the image is the name of the variable. So in case of <code>${firstname}</code>
			the image contains <em>firstname</em>. Each rule puts the token on the context (<code>ParserCV.setToken(aCtx, t);</code>), if
			available puts the image on the context and calls the routine <code>executeTokenHandler</code> passing the context and the current
			mode (which corresponds to the scanner state) as arguments. All the other rules look very similar to this one. So the next interesting
			thing is the routine <code>executeTokenHandler</code>:
		</p>
<source><![CDATA[
	private void executeTokenHandler(Map aCtx, String aMode)
	{
		ParserModeCV.setMode(aCtx, aMode);
		sm.execute(aCtx);
	}
]]></source>

		<p>
			It first sets the passed mode on the context and then calls <code>sm.execute(aCtx);</code>. <code>sm</code> stands for
			StateMachine and if you look at the top of the class you can find it's declaration:
		</p>
<source><![CDATA[
	private CollageStateMachine sm = new CollageStateMachine();
]]></source>

		<p>
			<code>CollageStateMachine</code> implements a finite state machine corresponding to the following diagram:
		</p>

		<figure src="images/collage-state.jpg" alt="images/collage-state.jpg"/>
	    </section>

		<p>
			So each time a token is detected <code>sm.execute(aCtx);</code> is invoked which causes a transition in the statemachine
			according to the diagram. In addition most transitions execute an action when they transfer the statemachine from one state
			to the following. The statemachine is constructed in the class <code>CollageStateMachine</code>.
			The following table contains the states and the one afterwards the transitions and their associated actions:
		</p>
		<table>
			<tr>
				<th>State</th><th>enter</th><th>execute</th><th>exit</th>
			</tr>
			<tr>
				<td>1: Start (StartState)</td><td></td><td></td><td>RootNodeCH</td>
			</tr>
			<tr>
				<td>2: Text (TextState)</td><td></td><td></td><td></td>
			</tr>
			<tr>
				<td>3: Java (JavaCodeState)</td><td></td><td></td><td></td>
			</tr>
			<tr>
				<td>4: Variable (VariableTextState)</td><td></td><td></td><td></td>
			</tr>
			<tr>
				<td>5: End (EndState)</td><td></td><td></td><td></td>
			</tr>
			<tr>
				<td>6: Error (not implemented yet)</td><td></td><td></td><td></td>
			</tr>
			<tr>
				<td>7: JavaEolChk (JavaEolChkState)</td><td></td><td></td><td></td>
			</tr>
		</table>
		<p></p>
		<table>
			<tr>
				<th>Transition</th>
				<th>condition (ParserModeCV.KEY_...)</th>
				<th>executeCmd</th>
			</tr>
			<tr><td>1 - 2 (StartToTextTransition)</td><td>TEXT</td><td>CsmStartTextCommand, CsmAppendTextCommand</td></tr>
			<tr><td>1 - 3 (StartToJavaCodeTransition)</td><td>JAVA_START</td><td>CsmStartJavaCommand</td></tr>
			<tr><td>1 - 4 (StartToVariableTextTransition)</td><td>VAR_START</td><td></td></tr>
			<tr><td>1 - 5 (StartToEofTransition)</td><td>EOF</td><td></td></tr>
			<tr><td>2 - 2 (TextToTextTransition)</td><td>TEXT</td><td>CsmAppendTextCmd</td></tr>
			<tr><td>2 - 2 EOL (TextToTextIfEolTransition)</td><td>EOL</td><td>CsmAppendEolCmd</td></tr>
			<tr><td>2 - 3 (TextToJavaCodeTransition)</td><td>JAVA_START</td><td>CsmFlushTextCmd, CsmStartJavaCmd</td></tr>
			<tr><td>2 - 4 (TextToVariableTextTransition)</td><td>VAR_START</td><td>CsmFlushTextCmd</td></tr>
			<tr><td>2 - 5 (TextToEndTransition)</td><td>EOF</td><td>FlushTextCmd</td></tr>
			<tr><td>3 - 3 (JavaCodeToJavaCodeTransition)</td><td>JAVA_CODE</td><td>CsmAppendJavaCmd</td></tr>
			<tr><td>3 - 7 (JavaCodeToJavaEolChkTransition)</td><td>JAVA_END</td><td>CsmFlushJavaCmd</td></tr>
			<tr><td>3 - 5 (JavaCodeToEndTransition)</td><td>EOF</td><td></td></tr>
			<tr><td>4 - 4 (VariableTextToVariableTextTransition)</td><td>VAR_NAME</td><td>CsmCreateVariableDomNodeCommand</td></tr>
			<tr><td>4 - 2 (VariableTextToTextTransition)</td><td>VAR_END</td><td>CsmStartTextCmd</td></tr>
			<tr><td>4 - 5 (VariableTextToEndTransition)</td><td>EOF</td><td></td></tr>
			<tr><td>7 - 2/EOL (JavaEolChkToTextIfEolTransition)</td><td>EOL</td><td>CsmStartTextCmd</td></tr>
			<tr><td>7 - 2/TEXT (JavaEolChkToTextIfTextTransition)</td><td>TEXT</td><td>CsmStartTextCmd, CsmAppendTextCmd</td></tr>
		</table>

		<p>
			The commands listed in the table above are responsible for building the individual parts of the DOM of the compiled
			template. If we look at <code>CsmCreateVariableDomNodeCommand</code> for example:
		</p>
<source><![CDATA[
public class CsmCreateVariableDomNodeCommand implements IXCommand
{
  public void execute(Map aCtx)
  {
    String value = ParserCV.getValue(aCtx);
    ModeContextView.setMode(aCtx, DomNodeCreationHandlerModeCV.KEY_VARIABLE);
    DomNodeCreationHandlerCV.setValue(aCtx, value);
    IXCommand dnch = DomNodeCreationHandlerCV.getDomNodeCreationHandler(aCtx);
    dnch.execute(aCtx);
  }
}
]]></source>

		<p>
			we can see that a <em>DomNodeCreationHandler</em> which is responsible for the creation of the individual DOM nodes.
			This way, if desired, different DomNodeCreationHandlers could be used if the default one would not be appropriate.
			But let us concentrate on the default behavior. The mode for DOM node creation is set to <em>KEY_VARIABLE</em> which
			will cause the DomNodeCreationHandler later to create a node for a variable. Next the value (the variablename in this case)
			is set on the context. Then we retrieve a reference to the configured DomNodeCreationHandler and call <code>execute</code>
			on it. After this call a DOM node for the variable has been created and stored in the context. If you will look at
			the other <code>Csm*</code> classes you will find that they all work very similar.
		</p>

		<p>
			So let us have a closer look at the <em>DomNodeCreationHandler</em>. The default one (set by the <em>TemplateCompiler</em> is
			<code>DomNodeCreationHandlerDispatcher</code>. If you look at it's code you can find that it maps modes to commands
			as defined in the following table:
		</p>
		<table>
			<tr> <th>Mode</th> <th>Command</th> </tr>
			<tr> <td>DomNodeCreationHandlerModeCV.KEY_START</td> <td>RootNodeCreationHandler</td> </tr>
			<tr> <td>DomNodeCreationHandlerModeCV.KEY_TEXT</td> <td>TextNodeCreationHandler</td> </tr>
			<tr> <td>DomNodeCreationHandlerModeCV.KEY_VARIABLE</td> <td>VariableNodeCreationHandler</td> </tr>
			<tr> <td>DomNodeCreationHandlerModeCV.KEY_JAVA_CODE</td> <td>JavaNodeCreationHandler</td> </tr>
		</table>

		<p>
			This means that when the <em>DomNodeCreationHandler</em> is invoked it will select the command assiciated with the
			current mode and will invoke it's <code>execute</code> method. To illustrate it on our example: since
			<code>CsmCreateVariableDomNodeCommand</code> set the mode to <code>DomNodeCreationHandlerModeCV.KEY_VARIABLE</code>
			the <em>DomNodeCreationHandler</em> will select the <em>VariableNodeCreationHandler</em> and execute it.
		</p>

		<p>
			If necessary it would be very easy to adapt this behavior. Simple setup another mode to command mapping in a new
			<em>DomNodeCreationHandler</em> and configure it on the context using
		</p>

<source><![CDATA[
DomNodeCreationHandlerCV.setDomNodeCreationHandler(aCtx, newDomNodeCreationHandler);
]]></source>


		<p>
			So what are the individual CreationHandlers doing? <code>RootNodeCreationHandler</code> , which is invoked at the beginning
			of the parsing process will create a new DOM <code>RootNode</code> and attaches it to the context.
			<code>VariableNodeCreationHandler</code> takes the value from the context, constructs a new DOM <code>VariableNode</code>
			from it and then attaches it as child to the rootnode.
		</p>

		<p>
			When the parsing process finishes we end up with a fully constructed DOM tree which is stored in the context and
			accessible via the call <code>DomCV.getRootNode(aCtx)</code>. This RootNode of the DOM represents the compiled template. In
			situations where the template is used more than once it makes sense of course to keep this DOM node so that the whole parsing
			process does not need to be done again.
		</p>


    </section>



	<section id="template_evaluation">
	<title>Template Evaluation</title>
	<p>
		To create our end result (the resolved String) this DOM needs to be evaluated. To do this an <em>evaluator</em> will be provided
		with the dynamic data. This evaluator then will traverse the nodes of the DOM (see Visitor pattern) and apply the data where
		possible. If the data contains values of the VariableNode currently traversed for example the data will be applied. When the
		traversal process is finished the resolved template is available. The result can be either retrieved as a String or the Evaluator
		can be told to write the result to a <code>Writer</code> during the traversal phase which is much more memory friendly of course
		and is recommended for usage in webapplications for example. We will see later how collage supports this.
	</p>
	
	<p>
		Collage has comes with evaluators for the most common situations. One of them is located in the package
		<code>org.collage.dom.evaluator.domdumper</code> and although it is not very useful it serves as a good demonstration example on how
		to implement evaluators (originally it has been made for debugging purposes while developing collage). So let us look at this example
		implementation in more detail.
	</p>
	
	<p>
		For the implementation of an evaluator create a separate Java package and inside it create a class <code>Evaluator</code> which
		needs to inherit from <code>NodeVisitor</code> to get the visitor behavior. This class is responsible to tell the visitor what
		to do for which DOM Node. Here is the DomDumper implementation:
	</p>
<source><![CDATA[
public class Evaluator extends NodeVisitor
{
  public Evaluator()
  {
    setConfigContext(configCtx);
  }

  private static Map configCtx = new HashMap();

  static
  {
    configCtx.put(TextNode.class, new TextNodeDumper());
    configCtx.put(VariableNode.class, new VariableNodeDumper());
    configCtx.put(JavaNode.class, new JavaNodeDumper());
  }
}
]]></source>

	<p>
		All you need to do in an Evaluator is to setup a Map which maps DomNodes to DomNodeHandlers which implement <em>IXCommand</em>.
		This means e.g. that whenever the visitor process detects a <em>TextNode</em> the <em>TextNodeDumper</em>'s <code>execute</code> method.
		Here is how <em>VariableNodeDumper</em> looks like for example:
	</p>

<source><![CDATA[
public class VariableNodeDumper implements IXCommand
{
  public void execute(Map aCtx)
  {
    VariableNode node = (VariableNode) EvaluationCV.getNode(aCtx);
    System.out.println("@@@ VARIABLE: '" + node.getVariableName() + "'");
  }
}
]]></source>

	<p>
		With <em>EvaluationCV.getNode(aCtx)</em> we get the currently by the visitor traversed DOM Node, which we can downcast in this case
		to a <code>VariableNode</code> since we know, we have a node of this type at the moment (because that's how we configured the Evaluator).
		Now that we have the <code>VariableNode</code> we can do whatever we like with it. <code>VariableNodeDumper</code> simply prints out the
		name of the variable. A more sophisticated handler could (as we see later) try to find an entry in <code>aCtx</code> for that variable name
		and thus print out the value of the variable as well.
	</p>
	<p>
		If you look at <em>TextNodeDumper</em> or <em>JavaNodeDumper</em> you will recognize that they all work very similar. To setup your own
		Evaluator you simply need to create such an Evaluator in you new package, associated handler for each DOM Node type as in the example and
		configure the mapping in the Evaluator.
	</p>

	<p>
		Of course collage comes with some real useful evaluators. One of the is the <em>text</em> evaluator in package
		<code>org.collage.dom.evaluator.text</code>. It's purpose is to write the evaluated template to a Writer (available in the context
		via <code>EvaluationCV.getWriter(aCtx)</code>).
	</p>

	<p>
		The most interesting evaluator is the <em>Java/javassist evaluator</em>. In contrast to the other evaluators where for each evaluation a new
		visitor process is executed which traverses the DOM tree this evaluator creates a Java source text while visiting the Nodes. When the
		visiting process is done a complete Java source text has been created in memory (this class also implements <em>IXCommand</em> of course).
		Using the library javassist this Java source text is compiled and an instance of it is created in memory. So the result of the evaluation
		process is not a text output of dynamic data applied to a template but a Java class representing the template itself. This means instead of
		the DOM Root node we have this Java object as a representation of the compiled template. Of course this is much easier to use than the DOM node.
		In addition it fully supports the execution of Java instructions appearing in the template.
	</p>
	<p>
		We won't go into the details on how javassist is applied here. If you are interesed in the details have a look at class <em>RootNodeEvaluator</em>
		and the javassist homepage.
	</p>

    </section>


	<section id="template_usage">
	<title>Template Usage</title>
	<p>
		To easily use templates and hide the complex details of <em>TemplateCompiler</em> for each evaluation technology an associated
		Template implementation exist. Common to all template implementations is that they all take a <em>TemplateSource</em> they work on.
		<em>TemplateSource</em> can be created from different input means like an <em>InputStream</em> or a <em>String</em> for example.
		Having the different input means hiden in <em>TemplateSource</em> means that the Templates need only to deal with <em>TemplateSource</em>
		and do not have to care about where the original imput source came from.
	</p>
	<p>
		All concrete Template classes inherit from the general <em>Template</em> class which is responsible to hide the detailed access to the
		<em>TemplateCompiler</em>. What the concrete Template classes need to do is to say which evaluator should be used. Here is the simple
		implementation for <em>TextTemplate</em> as an example:
	</p>
<source><![CDATA[
package org.collage.template;

import org.collage.dom.evaluator.NodeVisitor;
import org.collage.dom.evaluator.text.Evaluator;

public class TextTemplate extends Template
{
  public TextTemplate(TemplateSource aTemplateSource)
  {
    super(aTemplateSource);
  }

  protected NodeVisitor getDefaultNodeVisitor()
  {
    return defaultTextTemplateNodeVisistor;
  }

  private static NodeVisitor defaultTextTemplateNodeVisistor = new Evaluator();
}
]]></source>


	<p>
		As you can see all it needs to do is redefine <em>getDefaultNodeVisitor()</em> and return the appropriate <em>NodeVisistor</em> (parent
		class of all <em>Evaluator</em>s). The <em>JavassistTemplate</em> is a bit more complex due to it's different nature (see explanation of
		the Java evaluator).
	</p>

	<p>
		Using the TextTemplate works like this for example:
	</p>
<source><![CDATA[
  Template t = new TextTemplate(new TemplateSource("hallo ${firstname}.\nHow are you?\n"));
  String s = t.getStringResult(dataCtx);
  System.out.println(s);
]]></source>

	<p>
		Instead of getting the String result you can write the result on the fly to a writer which is more memory and performance friendly:
	</p>
<source><![CDATA[
  ...
  t.writeTo(dataCtx, new PrintWriter(System.out));
]]></source>


    </section>

</body>
</document>
